<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 10.2: GitOps (ArgoCD) - CodeWithMSMAXPRO</title>
    
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css">

    <style>
        /* --- Page-Specific Styles --- */
        html, body {
            overflow-x: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #0f172a;
            background-image: linear-gradient(145deg, #0f172a 0%, #1e293b 100%);
            color: #cbd5e1;
            line-height: 1.7;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background-color: transparent;
            padding: 1.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-weight: 700;
            font-size: 1.6rem;
            color: #ffffff;
            text-decoration: none;
            display: flex;
            align-items: center;
            z-index: 1000;
        }
        .logo img {
            height: 40px;
            margin-right: 10px;
        }
        .nav-links {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
        }
        .nav-links li {
            margin-left: 30px;
        }
        .nav-links li a {
            text-decoration: none;
            color: #cbd5e1;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .nav-links li a:hover {
            color: #7c3aed;
        }

        .hamburger {
            display: none;
            cursor: pointer;
            z-index: 1000;
        }
        .hamburger div {
            width: 25px;
            height: 3px;
            background-color: #ffffff;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        section {
            padding: 60px 0;
        }
        
        .page-title { 
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 50px;
            font-weight: 700;
            color: #ffffff;
        }
        
        /* --- HIGHLIGHT COLOR (ADVANCED K8S) --- */
        .highlight {
            background: linear-gradient(90deg, #6366f1, #a855f7); /* Indigo/Purple */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        footer {
            text-align: center;
            padding: 25px 0;
            margin-top: 40px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #94a3b8;
        }
        
        /* --- Content-Specific Styles --- */
        .content-section {
            padding-top: 0;
        }
        
        .content-section h2 {
            font-size: 2.2rem;
            color: #fff;
            margin-top: 40px;
            margin-bottom: 10px;
            border-bottom: 2px solid #334155;
            padding-bottom: 10px;
        }
        
        .content-section h3 {
            font-size: 1.8rem;
            color: #e2e8f0;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .content-section h4 {
            font-size: 1.4rem;
            color: #6366f1; /* Indigo highlight */
            margin-top: 25px;
            margin-bottom: 10px;
        }

        .content-section p, .content-section li {
            font-size: 1.1rem;
            color: #cbd5e1;
            margin-bottom: 15px;
        }
        
        .content-section ul, .content-section ol {
            padding-left: 25px;
        }
        
        /* Code Block Style */
        .content-section pre {
            background-color: #1e293b;
            border: 1px solid #334155;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.95rem;
        }
        
        /* Simple inline code block */
        .content-section code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1e293b;
            padding: 2px 5px;
            border-radius: 4px;
            color: #f472b6;
        }

        /* Full code block syntax highlighting */
        .content-section pre code {
            font-family: 'Courier New', Courier, monospace;
            color: #e2e8f0;
            background: none;
            padding: 0;
        }
        
        /* Syntax Highlighting for YAML/Bash */
        .content-section pre code .comment { color: #64748b; }
        .content-section pre code .keyword { color: #f472b6; } /* apiVersion, kind, metadata, spec */
        .content-section pre code .property { color: #38bdf8; } /* name, replicas, containers, image */
        .content-section pre code .string { color: #a78bfa; } /* "nginx", "v1" */
        .content-section pre code .number { color: #f59e0b; } /* 3, 80 */
        .content-section pre code .command { color: #34d399; } /* istioctl, kubectl, docker */
        

        /* Read More Link */
        .read-more-link {
            display: inline-block;
            margin-top: 15px;
            font-weight: 700;
            color: #a78bfa;
            text-decoration: none;
            font-size: 1.1rem;
        }
        .read-more-link:hover {
            text-decoration: underline;
        }
        
        /* Navigation Buttons */
        .page-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            border-top: 1px solid #334155;
            padding-top: 30px;
        }
        
        .cta-button {
            background: linear-gradient(90deg, #f97316, #ef4444);
            color: #ffffff;
            padding: 12px 25px;
            text-decoration: none;
            font-weight: 700;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .cta-button:hover {
            opacity: 0.9;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .cta-button.prev {
            background: #334155;
        }
        .cta-button.prev:hover {
            background: #475569;
        }
        
        /* Mobile Nav Styles */
        @media (max-width: 768px) {
            .logo span { display: none; }
            .nav-links { position: fixed; right: 0px; height: 100vh; top: 0; background-color: #1e293b; display: flex; flex-direction: column; align-items: center; justify-content: space-evenly; width: 60%; transform: translateX(100%); transition: transform 0.5s ease-in; z-index: 999; }
            .nav-links li { margin-left: 0; opacity: 0; }
            .hamburger { display: block; }
        }
        .nav-active { transform: translateX(0%); }
        .nav-active li { opacity: 1; transition: opacity 0.5s ease 0.3s; }
        .toggle .line1 { transform: rotate(-45deg) translate(-5px, 6px); }
        .toggle .line2 { opacity: 0; }
        .toggle .line3 { transform: rotate(45deg) translate(-5px, -6px); }
    </style>
</head>
<body>

    <header>
        <div class="container">
            <nav>
                <a href="index.html" class="logo">
                    <img src="images/logo.png" alt="CodeWithMSMAXPRO Logo">
                    <span>CodeWithMSMAXPRO</span>
                </a>
                
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="roadmaps.html">Roadmaps</a></li>
                    <li><a href="blog.html">Blog</a></li>
                    <li><a href="portfolio.html">Portfolio</a></li> 
                    <li><a href="about.html">About</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
                
                <div class="hamburger">
                    <div class="line1"></div>
                    <div class="line2"></div>
                    <div class="line3"></div>
                </div>
            </nav>
        </div>
    </header>

    <main>
        <section class="content-section">
            <div class="container">
                <h1 class="page-title">Chapter 10.2: <span class="highlight">GitOps (ArgoCD)</span></h1>
                
                <!-- ========================== -->
                <!-- SECTION 1: Introduction -->
                <!-- ========================== -->
                
                <h2>Part 1: The "Why" - What is GitOps?</h2>
                <p>We've learned how to build CI/CD pipelines (Chapter 4) and how to deploy to Kubernetes (Chapter 6.2). The standard way to deploy is a **"push"** model. Your CI pipeline (e.g., GitHub Actions) runs a command at the end:</p>
                <p><code>$ kubectl apply -f deployment.yml</code></p>
                <p>This "pushes" the configuration to your cluster. This works, but it has serious problems in large-scale systems:</p>
                
                <h3>The Problems with the "Push" Model:</h3>
                <ul>
                    <li><strong>No Single Source of Truth:</strong> What is *actually* running in your cluster? To find out, you have to run <code>kubectl get deployment</code>. But what if a developer (with <code>kubectl</code> access) manually changes a running deployment using <code>kubectl edit ...</code>? Now your Git repo (which says <code>image: v1</code>) is **lying**. The cluster is running <code>image: v1-hotfix</code>. This is called **"Configuration Drift"** and it's a nightmare.</li>
                    <li><strong>Security:** Your CI pipeline needs *admin-level credentials* (a <code>kubeconfig</code> file) to your production cluster. This is a massive security risk. If a hacker gets into your CI, they own your entire cluster.</li>
                    <li><strong>Rollbacks are Hard:</strong> To roll back, you have to find the *old* YAML file and re-run <code>kubectl apply</code> on it. This is a slow, manual process during an emergency.</li>
                </ul>
                
                <h3>The Solution: GitOps (A "Pull" Model)</h3>
                <p><strong>GitOps** is a modern, declarative way to manage and deploy to Kubernetes. It's built on one core principle:
                <br>
                **Git is the Single Source of Truth.**
                <br>
                The *only* way to make a change to production is to make a <code>git push</code> to a specific branch in a specific Git repository. No one (not even the senior-most admin) is allowed to use <code>kubectl apply</code> or <code>kubectl edit</code>.</p>
                
                <p>How does this work? You install an "operator" (a robot) *inside* your Kubernetes cluster. The most popular one is **ArgoCD**.</p>
                
                <ol>
                    <li>You create a Git repo dedicated to your K8s config (e.g., <code>my-app-k8s-config</code>).</li>
                    <li>You install **ArgoCD** inside your cluster.</li>
                    <li>You tell ArgoCD: "Your job is to constantly *watch* the <code>main</code> branch of the <code>my-app-k8s-config</code> repo."</li>
                    <li>ArgoCD then enters a loop: It "pulls" the YAML from Git (the **Desired State**) and compares it to what's *actually* running in the cluster (the **Live State**).</li>
                    <li>If it sees *any* difference ("Configuration Drift"), it marks the app as "OutOfSync" and (if you want) **automatically fixes it**.</li>
                </ol>
                
                <p>If a developer runs <code>kubectl edit</code> and changes the image, ArgoCD will see the drift in 3 minutes and *automatically* change it back. **Git is the boss.**</p>
                <p><strong>To Deploy (v2):** A developer *never* touches <code>kubectl</code>. They just make a Pull Request to the `my-app-k8s-config` repo, changing the image from <code>v1</code> to <code>v2</code>. Once that PR is merged, ArgoCD sees the change in Git and automatically runs the <code>kubectl apply</code> *for them*.
                <br>
                <strong>To Rollback:** You just run <code>git revert</code>. ArgoCD sees the "new" commit (which is actually the old state) and automatically rolls the app back to v1.</p>
                
                <p>This gives you a **fully automated, 100% auditable, and secure** deployment system where every change is a Git commit.</p>
                
                <!-- ========================== -->
                <!-- SECTION 2: ArgoCD Setup -->
                <!-- ========================== -->
                
                <h2>Part 2: Installing & Setting Up ArgoCD</h2>
                <p>ArgoCD is a set of services you install directly into your Kubernetes cluster.</p>
                
                
                <h3>Step 1: Install ArgoCD on your Cluster (e.g., Minikube)</h3>
                <p>This will create a new <code>argocd</code> namespace and install all the necessary components (API Server, Controller, Repo Server).</p>
                <pre><code><span class="comment"># 1. Create the namespace</span>
$ <span class="command">kubectl</span> create namespace argocd

<span class="comment"># 2. Apply the official installation YAML from GitHub</span>
$ <span class="command">kubectl</span> apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
<span class="comment_output">
service/argocd-server created
deployment.apps/argocd-repo-server created
... (and many more)
</span>
</code></pre>
                
                <h3>Step 2: Install the ArgoCD CLI (on your laptop)</h3>
                <p>This is the command-line tool (like <code>kubectl</code>) that you use to talk to the ArgoCD API server.</p>
                <pre><code><span class="comment"># On macOS (using Homebrew)</span>
$ brew install argocd

<span class="comment"># On Linux</span>
$ <span class="command">curl</span> -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
$ <span class="command">sudo</span> install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
$ <span class="command">rm</span> argocd-linux-amd64
</code></pre>
                
                <h3>Step 3: Access the ArgoCD UI (via Port-Forwarding)</h3>
                <p>By default, the ArgoCD server is not exposed to the internet (it's a <code>ClusterIP</code> service). For local development, you use <code>kubectl port-forward</code> to access it.</p>
                <pre><code><span class="comment"># This forwards your laptop's port 8080 to the argocd-server's port 80</span>
<span class="comment"># (Run this in a separate terminal and leave it running)</span>
$ <span class="command">kubectl</span> port-forward svc/argocd-server -n argocd 8080:80
</code></pre>
                <p>You can now open <code>http://localhost:8080</code> in your browser to see the ArgoCD UI!</p>
                
                <h3>Step 4: Log In (Get the Admin Password)</h3>
                <p>ArgoCD automatically generates a default admin password and stores it in a K8s Secret.</p>
                <pre><code><span class="comment"># 1. Get the name of the secret</span>
$ <span class="command">kubectl</span> get secrets -n argocd | <span class="command">grep</span> argocd-initial-admin-secret
<span class="comment_output">
argocd-initial-admin-secret   ...
</span>

<span class="comment"># 2. Get the 'password' field from that secret and decode it</span>
$ <span class="command">kubectl</span> -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | <span class="command">base64</span> -d
<span class="comment_output">
<span class="string">MY_SECRET_PASSWORD_12345</span>
</span>
</code></pre>
                <p>You can now log in to the UI (<code>http://localhost:8080</code>) or the CLI with:
                <br>
                **Username:** <code>admin</code>
                <br>
                **Password:** (The password you just got)</p>
                
                <pre><code><span class="comment"># Log in with the CLI</span>
$ <span class="command">argocd</span> login localhost:8080
<span class="comment_output">
WARNING: server is not configured with TLS.
Username: admin
Password: ********************
'admin:login' logged in successfully
</span>
</code></pre>
                
                <a href="https://argo-cd.readthedocs.io/en/stable/getting_started/" target="_blank" class="read-more-link">Read the Official ArgoCD Getting Started Guide &rarr;</a>
                
                <!-- =================================== -->
                <!-- PART 3: The Application CRD -->
                <!-- =================================== -->
                
                <h2>Part 3: The `Application` CRD (The "What")</h2>
                <p>How do you tell ArgoCD to monitor your Git repo? You create a new Kubernetes object with <code>kind: Application</code>. This is a **Custom Resource Definition (CRD)** that ArgoCD installs.</p>
                <p>This <code>Application</code> object is the *core* of GitOps. It tells ArgoCD: "This is the app. This is its Git repo. This is its target cluster."</p>
                
                <h4>Example: An `Application` YAML</h4>
                <p>Let's say you have a Git repo at `https://github.com/msmaxpro/my-app-k8s-config` that contains your <code>deployment.yml</code> and <code>service.yml</code>.</p>
                
                <span class="code-filename">argocd-app.yml</span>
                <pre><code><span class="property">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span>
<span class="property">kind:</span> <span class="string">Application</span>
<span class="property">metadata:</span>
  <span class="property">name:</span> <span class="string">my-web-app</span>
  <span class="property">namespace:</span> <span class="string">argocd</span> <span class="comment"># This object must live in the 'argocd' namespace</span>
<span class="property">spec:</span>
  <span class="comment"># 1. 'project': Which project this app belongs to</span>
  <span class="property">project:</span> <span class="string">default</span>
  
  <span class="comment"># 2. 'source': The "Desired State" (Your Git Repo)</span>
  <span class="property">source:</span>
    <span class="property">repoURL:</span> <span class="string">https://github.com/msmaxpro/my-app-k8s-config.git</span>
    <span class="property">targetRevision:</span> <span class="string">HEAD</span> <span class="comment"># Track the latest commit</span>
    <span class="property">path:</span> <span class="string">prod</span> <span class="comment"># Look for YAMLs in the 'prod' folder of this repo</span>
    
  <span class="comment"># 3. 'destination': The "Live State" (Your K8s Cluster)</span>
  <span class="property">destination:</span>
    <span class="property">server:</span> <span class="string">https://kubernetes.default.svc</span> <span class="comment"># 'kubernetes.default.svc' is the internal alias for "this cluster"</span>
    <span class="property">namespace:</span> <span class="string">production</span> <span class="comment"># Deploy the app into the 'production' namespace</span>
    
  <span class="comment"># 4. 'syncPolicy': How to sync (optional)</span>
  <span class="property">syncPolicy:</span>
    <span class="property">automated:</span>
      <span class="property">prune:</span> <span class="keyword">true</span>
      <span class="property">selfHeal:</span> <span class="keyword">true</span>
</code></pre>
                
                <h3>How to Apply This:</h3>
                <p>You apply this file *once* to your cluster:</p>
                <pre><code>$ <span class="command">kubectl</span> apply -f argocd-app.yml -n argocd
<span class="comment_output">application.argoproj.io/my-web-app created</span>
</code></pre>
                <p>As soon as you do this, ArgoCD's "Application Controller" sees the new object. It will:
                <br>
                1. Clone your `https://github.com/msmaxpro/my-app-k8s-config.git` repo.
                <br>
                2. Look in the `prod` folder.
                <br>
                3. Read all the YAML files (<code>deployment.yml</code>, <code>service.yml</code>).
                <br>
                4. Compare them to what's in the `production` namespace.
                <br>
                5. See that *nothing* is running, and declare the app "OutOfSync".
                <br>
                6. (Because we set <code>automated: true</code>) It will then automatically run <code>kubectl apply</code> on those files *for you*.
                <br>
                7. Your app is now deployed!</p>
                
                <!-- =================================== -->
                <!-- PART 4: SyncPolicy Deep Dive -->
                <!-- =================================== -->
                
                <h2>Part 4: Deep Dive - The `syncPolicy`</h2>
                <p>This is the "magic" of GitOps. It controls how ArgoCD fixes "Configuration Drift."</p>
                
                <h4>`syncPolicy: {}` (Manual Sync)</h4>
                <p>If you don't set an <code>automated</code> policy (or leave it empty), ArgoCD will be in **Manual Sync** mode.
                <br>
                - You merge a PR to update the `image: v2` in Git.
                <br>
                - ArgoCD detects this. It shows a big "OutOfSync" button in its UI.
                <br>
                - Your app is **still running v1**.
                <br>
                - A human must log in to the ArgoCD UI and click the **"SYNC"** button.
                <br>
                - *Then*, ArgoCD will run <code>kubectl apply</code> and deploy v2.
                <br>
                This is safe, and is a form of "Continuous Delivery" (with manual approval).</p>
                
                <h4>`syncPolicy: { automated: {} }` (Automated Sync)</h4>
                <p>This is **Continuous Deployment**.
                <br>
                - You merge a PR to update the `image: v2` in Git.
                <br>
                - ArgoCD detects this (within 3 minutes by default).
                <br>
                - ArgoCD *immediately* runs <code>kubectl apply</code> and deploys v2.
                <br>
                - No human intervention required.</p>
                
                <h4>`prune: true` (Auto-Deletion)</h4>
                <p>What if you *delete* <code>service.yml</code> from your Git repo?
                <br>
                - If <code>prune: false</code> (the default), ArgoCD will just show "OutOfSync." The <code>Service</code> will *keep running* in your cluster.
                <br>
                - If <code>prune: true</code>, ArgoCD will see the <code>Service</code> exists in the cluster but *not* in Git, and will **automatically run <code>kubectl delete svc/my-service</code>** to remove it.</p>
                
                <h4>`selfHeal: true` (The "Anti-kubectl" Shield)</h4>
                <p>This is the most important feature for enforcing Git as the source of truth.
                <br>
                - A developer logs in at 3 AM and runs <code>kubectl edit deployment my-web-app --image=v3-hotfix</code>.
                <br>
                - Your "Live State" (v3-hotfix) is now different from your "Desired State" (v2).
                <br>
                - If <code>selfHeal: false</code> (the default), ArgoCD will just show "OutOfSync" and do nothing.
                <br>
                - If <code>selfHeal: true</code>, ArgoCD will detect this drift and **automatically run <code>kubectl apply</code>** to change the image *back* to `v2`, "healing" the cluster and overriding the manual change.
                <br>
                This forces all changes to go through Git.</p>
                
                <!-- =================================== -->
                <!-- PART 5: Full Workflow Example -->
                <!-- =================================== -->
                
                <h2>Part 5: The Full GitOps Workflow</h2>
                <p>Here is the complete, end-to-end loop for a professional DevOps team.</p>
                
                <h3>The Setup</h3>
                <ol>
                    <li>**Repo 1: `my-node-app` (The App Code)**
                        <ul><li>Contains your <code>app.js</code>, <code>package.json</code>, and <code>Dockerfile</code>.</li></ul>
                    </li>
                    <li>**Repo 2: `my-k8s-config` (The GitOps Repo)**
                        <ul><li>Contains your <code>deployment.yml</code> (which points to <code>image: my-app:v1</code>) and <code>service.yml</code>.</li></ul>
                    </li>
                    <li>**CI Pipeline (GitHub Actions on `my-node-app`)**
                        <ul><li>A workflow that triggers on `push` to <code>main</code>.</li></ul>
                    </li>
                    <li>**CD (ArgoCD)**
                        <ul><li>An <code>Application</code> object inside Kubernetes that "watches" the `my-k8s-config` repo.</li></ul>
                    </li>
                </ol>
                
                <h3>The Workflow in Action:</h3>
                
                <ol>
                    <li><strong>Dev:** A developer makes a code change (e.g., adds a new API endpoint) to <code>my-node-app</code> and pushes to a feature branch.</li>
                    <li><strong>PR:** The developer opens a Pull Request.</li>
                    <li><strong>CI (GitHub Actions):</strong> The CI pipeline on `my-node-app` triggers.
                        <ul>
                            <li>Builds the code.</li>
                            <li>Runs unit tests.</li>
                            <li>Runs SAST, SCA, and Secret scans.</li>
                        </ul>
                    </li>
                    <li><strong>Merge:** The PR is approved and merged into <code>main</code>.</li>
                    <li><strong>CI/CD (GitHub Actions):</strong> A *second* pipeline on `my-node-app` (triggered by <code>push</code> to <code>main</code>) runs:
                        <ul>
                            <li>Builds the production Docker image.</li>
                            <li>Tags it with the Git commit hash (e.g., <code>ghcr.io/msmaxpro/my-app:abc1234</code>).</li>
                            <li>Scans the image with Trivy.</li>
                            <li>**Pushes** the image to the GitHub Container Registry (GHCR).</li>
                        </ul>
                    </li>
                    <li><strong>(The Magic Step):** The *same* pipeline then:
                        <ul>
                            <li>Checks out the *other* repo (<code>my-k8s-config</code>).</li>
                            <li>Updates <code>deployment.yml</code> to change <code>image: my-app:v1</code> to <code>image: my-app:abc1234</code>.</li>
                            <li>Commits and pushes this change to the <code>my-k8s-config</code> repo.</li>
                        </ul>
                    </li>
                    <li><strong>GitOps (ArgoCD):**
                        <ul>
                            <li>ArgoCD (which is *always* watching) detects the new commit in <code>my-k8s-config</code>.</li>
                            <li>It sees the "Desired State" (image <code>abc1234</code>) is different from the "Live State" (image <code>v1</code>).</li>
                            <li>It automatically (because <code>selfHeal: true</code>) triggers a <code>kubectl apply</code>.</li>
                            <li>Kubernetes performs a rolling update, safely deploying your new code to production.</li>
                        </ul>
                    </li>
                </ol>
                <p>This entire process, from <code>git push</code> to production, is **100% automated** and **100% auditable** (every change is a Git commit).</p>
                
                <h3>The "App of Apps" Pattern</h3>
                <p>You don't want to run <code>kubectl apply -f argocd-app.yml</code> for all 500 of your apps. The "App of Apps" pattern is the solution.
                <br>
                1. You create one "root" <code>Application</code> object.
                <br>
                2. You point this *one* app at a Git repo (e.g., <code>all-my-apps</code>).
                <br>
                3. Inside *that* repo, there are no deployments, just 500 *other* <code>Application.yml</code> files.
                <br>
                Now, to add a new app to your company, you just add a new YAML file to the <code>all-my-apps</code> repo. ArgoCD sees it and *automatically creates the new ArgoCD Application*, which in turn automatically deploys your app.</p>
                
                <a href="https://argo-cd.readthedocs.io/en/stable/" target="_blank" class="read-more-link">Read the Official ArgoCD Documentation &rarr;</a>

                <!-- ========================== -->
                <!-- Page Navigation            -->
                <!-- ========================== -->

                <div class="page-nav">
                    <a href="devops-servicemesh-istio.html" class="cta-button prev">&larr; Chapter 10.1: Istio</a>
                    <a href="devops-roadmap.html" class="cta-button">Congratulations! (Back to Roadmap) &rarr;</a>
                </div>

            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CodeWithMSMAXPRO. All rights reserved.</p>
        </div>
    </footer>
    
    <script>
        const navSlide = () => {
            const hamburger = document.querySelector('.hamburger');
            const nav = document.querySelector('.nav-links');

            if (hamburger && nav) {
                hamburger.addEventListener('click', () => {
                    nav.classList.toggle('nav-active');
                    hamburger.classList.toggle('toggle');
                });
            }
        }
        navSlide();
    </script>

</body>
</html>
