<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Basics (MongoDB) - CodeWithMSMAXPRO</title>
    
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- General Styles --- */
        html, body {
            overflow-x: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #0f172a;
            background-image: linear-gradient(145deg, #0f172a 0%, #1e293b 100%);
            color: #cbd5e1;
            line-height: 1.8; /* Good line height for reading */
        }

        .container {
            max-width: 1100px; /* Default container */
            margin: 0 auto;
            padding: 0 20px;
        }

        section {
            padding: 60px 0;
        }

        footer {
            text-align: center;
            padding: 25px 0;
            margin-top: 40px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #94a3b8;
        }

        /* --- Header / Navigation Bar --- */
        header {
            background-color: transparent;
            padding: 1.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-weight: 700;
            font-size: 1.6rem;
            color: #ffffff;
            text-decoration: none;
            display: flex;
            align-items: center;
            z-index: 1000;
        }
        .logo img {
            height: 40px;
            margin-right: 10px;
        }
        .logo span {
            display: block;
        }
        .nav-links {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
        }
        .nav-links li {
            margin-left: 30px;
        }
        .nav-links li a {
            text-decoration: none;
            color: #cbd5e1;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .nav-links li a:hover {
            color: #7c3aed;
        }

        /* --- Hamburger Menu Icon --- */
        .hamburger {
            display: none;
            cursor: pointer;
            z-index: 1000;
        }
        .hamburger div {
            width: 25px;
            height: 3px;
            background-color: #ffffff;
            margin: 5px;
            transition: all 0.3s ease;
        }

        /* --- Content/Article Page Styles (Tutorials & Posts) --- */
        /* Set a smaller container for article pages */
        .content-container .container {
            max-width: 800px;
        }
        
        .content-header h1, .post-header h1 {
            font-size: 2.8rem;
            color: #ffffff;
            font-weight: 700;
            text-align: center;
            margin-bottom: 15px;
        }
        .content-meta, .post-meta {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 40px;
        }
        .content-body h2, .post-content h2 {
            font-size: 2.2rem;
            color: #ffffff;
            margin-top: 60px;
            text-align: left;
            border-bottom: 2px solid #38bdf8;
            padding-bottom: 10px;
        }
        .content-body h3, .post-content h3 {
            font-size: 1.7rem;
            color: #e0e0e0;
            margin-top: 40px;
            border-left: 3px solid #8b5cf6;
            padding-left: 15px;
        }
        .content-body p, .post-content p,
        .content-body ul, .post-content ul,
        .content-body ol {
            font-size: 1.1rem;
        }
        .content-body ul, .post-content ul,
        .content-body ol {
            padding-left: 25px;
        }
        .content-body li, .post-content li {
            margin-bottom: 10px;
        }
        .content-body code {
            background-color: #1e293b;
            padding: 3px 8px;
            border-radius: 6px;
            font-family: monospace;
            border: 1px solid #334155;
            color: #f8fafc;
        }
        pre {
            background-color: #1e293b;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #334155;
            overflow-x: auto;
        }
        pre code {
            display: block;
            padding: 0;
            white-space: pre-wrap;
            background-color: transparent;
            border: none;
        }
        .note {
            background-color: rgba(30, 41, 59, 0.7);
            border-left: 4px solid #facc15;
            padding: 20px;
            margin: 30px 0;
            border-radius: 8px;
        }
        .note strong {
            color: #facc15;
        }

        /* --- New MongoDB-green highlight for this page --- */
        .highlight {
            background: linear-gradient(90deg, #4DB33D, #90CC88); /* MongoDB Green */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* --- Responsive Design (Media Queries) --- */
        @media (max-width: 768px) {
            .logo span {
                display: none; /* Hide logo text on mobile */
            }
            .nav-links {
                position: fixed;
                right: 0px;
                height: 100vh;
                top: 0;
                background-color: #1e293b;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-evenly;
                width: 60%;
                transform: translateX(100%);
                transition: transform 0.5s ease-in;
                z-index: 999;
            }
            .nav-links li {
                margin-left: 0;
                opacity: 0;
            }
            .hamburger {
                display: block; /* Show hamburger on mobile */
            }
            
            h2 {
                font-size: 2.2rem;
            }
            .content-header h1, .post-header h1 {
                font-size: 2.2rem;
            }
        }

        /* --- JS-Toggled Classes for Mobile Menu --- */
        .nav-active {
            transform: translateX(0%);
        }
        .nav-active li {
            opacity: 1;
            transition: opacity 0.5s ease 0.3s;
        }
        .toggle .line1 {
            transform: rotate(-45deg) translate(-5px, 6px);
        }
        .toggle .line2 {
            opacity: 0;
        }
        .toggle .line3 {
            transform: rotate(45deg) translate(-5px, -6px);
        }
        
        /* --- Keyframes for Nav Link Animation --- */
        @keyframes navLinkFade {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="container">
            <nav>
                <a href="/" class="logo">
                    <img src="images/logo.png" alt="CodeWithMSMAXPRO Logo">
                    <span>CodeWithMSMAXPRO</span>
                </a>
                
                <ul class="nav-links">
                    <li><a href="/">Home</a></li>
                    <li><a href="roadmaps.html">Roadmaps</a></li>
                    <li><a href="blog.html">Blog</a></li>
                    <li><a href="about.html">About</a></li>
                    <li><a href="contact.html">Contact</a></li> 
                </ul>
                
                <div class="hamburger">
                    <div class="line1"></div>
                    <div class="line2"></div>
                    <div class="line3"></div>
                </div>
            </nav>
        </div>
    </header>

    <main>
        <section class="content-container">
            <div class="container"> <article class="content-body">
                    <div class="content-header">
                        <h1>Chapter 3: Databases (<span class="highlight">MongoDB</span> Basics)</h1>
                        <p class="content-meta">Backend Developer Roadmap</p>
                    </div>

                    <p>Our Express server is running, but it has no memory! Every time it restarts, any data it had is gone. To build real applications (like user accounts, blog posts, or e-commerce sites), we need a way to store data **persistently**, even when the server stops. This is the job of a **database**.</p>
                    <p>Think of a database as your application's long-term memory or a highly organized digital filing cabinet. Your Node.js/Express application acts as the librarian, talking to the database to file away new information (Create), find existing information (Read), change stored information (Update), or remove old information (Delete).</p>

                    <h2>Theory: SQL vs. NoSQL Databases</h2>
                    <p>Before diving into our chosen database, it's crucial to understand the two main philosophical approaches to storing data:</p>
                    
                    <h3>1. SQL (Relational Databases) - The Organized Spreadsheet</h3>
                    <ul>
                        <li><strong>What it is:</strong> Databases that store data in **tables** with predefined structures (**schemas**). Each table has **columns** (like 'UserID', 'Username', 'Email') and **rows** representing individual records. Think of a very structured Excel spreadsheet.</li>
                        <li><strong>Key Concept:</strong> **Relationships**. SQL databases excel at defining and enforcing links between different tables (e.g., linking a 'UserID' from the 'Users' table to an 'Orders' table to show which user made which order).</li>
                        <li><strong>Language:</strong> Uses **SQL (Structured Query Language)** to interact with the data (e.g., `SELECT * FROM users WHERE age > 18;`).</li>
                        <li><strong>Examples:</strong> PostgreSQL, MySQL, SQLite, Microsoft SQL Server.</li>
                        <li><strong>Pros:</strong> Data integrity (schema enforcement), powerful querying for related data, mature and widely understood technology (ACID compliance).</li>
                        <li><strong>Cons:</strong> Less flexible (changing the schema can be complex), scaling horizontally (across many servers) can be harder than NoSQL.</li>
                    </ul>

                    <h3>2. NoSQL (Non-Relational Databases) - The Flexible Filing Cabinet</h3>
                    <ul>
                        <li><strong>What it is:</strong> A broad category for databases that *don't* primarily use the table/row/column structure. They offer more flexibility in how data is stored.</li>
                        <li><strong>Key Concept:</strong> **Flexibility & Scalability**. NoSQL databases often handle unstructured or semi-structured data well and are typically designed for easier horizontal scaling.</li>
                        <li><strong>Types & Examples:</strong>
                            <ul>
                                <li>**Document Databases (like MongoDB):** Store data in JSON-like documents. Great for web apps where data often resembles objects.</li>
                                <li>**Key-Value Stores (like Redis):** Super fast for simple lookups based on a key (like a dictionary).</li>
                                <li>**Column-Family Stores (like Cassandra):** Optimized for writes and querying large datasets by column.</li>
                                <li>**Graph Databases (like Neo4j):** Designed specifically for data with complex relationships (like social networks).</li>
                            </ul>
                        </li>
                        <li><strong>Pros:</strong> Flexible schema (or schema-less), often easier to scale horizontally, can be very fast for certain workloads, good fit for evolving application requirements.</li>
                        <li><strong>Cons:</strong> Less mature than SQL for some use cases, data consistency might need more application-level handling (BASE consistency vs. ACID), querying complex relationships can sometimes be harder than in SQL.</li>
                    </ul>
                    
                    <div class="note">
                        <strong>Why MongoDB for Node.js?</strong> MongoDB is a **document database**. It stores data in a format called BSON, which is very similar to JSON (the native format of JavaScript objects). This makes it incredibly intuitive and easy to work with when building applications using Node.js and Express. You fetch data from Mongo, and it already looks like a JavaScript object!
                    </div>

                    <h2>Theory: Introducing MongoDB & Mongoose 🍃</h2>
                    
                    <h3>MongoDB Core Concepts</h3>
                    <p>Let's understand MongoDB's structure:</p>
                    
                    <ul>
                        <li>**Database:** The top-level container. You might have one database for your entire application (e.g., `codeWithMSMAXPRO_DB`).</li>
                        <li>**Collection:** A group of related documents. Think of it like a table in SQL, but much more flexible. You might have a `users` collection, a `posts` collection, etc.</li>
                        <li>**Document:** A single record, stored in BSON format. It's essentially a set of key-value pairs, like a JavaScript object. A document in the `users` collection might look like this:</li>
                    </ul>
<pre><code class="language-json">{
  "_id": ObjectId("some_unique_id_generated_by_mongo"),
  "username": "MSMAXPRO",
  "email": "msmaxpro@example.com",
  "age": 20,
  "createdAt": ISODate("2025-10-20T...") 
}
</code></pre>
                    <p>Notice the `_id`? MongoDB automatically creates a unique ID for every document.</p>

                    <h3>Mongoose: Making MongoDB Easier in Node.js</h3>
                    <p>While Node.js has an official driver to talk to MongoDB, **Mongoose** is an **ODM (Object Data Modeling)** library that provides a more elegant and structured way to interact with the database from your Express application.</p>
                    <p>It helps with:</p>
                    <ul>
                        <li>**Schema Definition:** Defining a blueprint for your documents, including data types (String, Number, Date, Boolean, Array, etc.) and validation rules (like `required`, `unique`, `min`, `max`). This brings some structure to the flexible nature of MongoDB.</li>
                        <li>**Models:** Creating 'Model' objects from your schemas. These models are your primary tool for interacting with a specific collection (e.g., a `User` model to interact with the `users` collection). They provide methods like `.find()`, `.create()`, `.findByIdAndUpdate()`, etc.</li>
                        <li>**Data Validation:** Automatically running your schema validation rules before saving data.</li>
                        <li>**Middleware:** Allowing you to run functions before or after certain operations (like saving a document).</li>
                        <li>**Query Building:** Offering a cleaner syntax for building complex database queries.</li>
                    </ul>
                    <p>Essentially, Mongoose adds a helpful abstraction layer, making your database code cleaner, safer, and easier to manage.</p>

                    <h2>Task: Setting Up MongoDB & Connecting with Mongoose</h2>
                    <p>Our first task is to get a database instance and connect our Express application to it using Mongoose.</p>
                    
                    <h3>Step 1: Get a MongoDB Database Instance</h3>
                    <p>For learning and development, the best option is the free tier on **MongoDB Atlas**, MongoDB's official cloud database service.</p>
                    
                    <h4>How to Perform (MongoDB Atlas Setup):</h4>
                    <ol>
                        <li>**Sign Up:** Create a free account at <a href="https://www.mongodb.com/cloud/atlas" target="_blank">MongoDB Atlas</a>.</li>
                        <li>**Create Cluster:** Build a new cluster, choosing the "Shared" (Free) option. Select a cloud provider (AWS, Google Cloud, Azure) and a region geographically close to you. Give your cluster a name (e.g., `Cluster0`).</li>
                        <li>**Configure Security:**
                            <ul>
                                <li>**Database User:** Under "Database Access", create a new database user. Choose "Password" authentication, set a strong username (e.g., `msmaxpro_user`) and password. **RECORD THESE SECURELY!** Assign the user "Read and write to any database" privileges (for now).</li>
                                <li>**Network Access:** Under "Network Access", click "Add IP Address". Choose "Allow Access From Anywhere" (`0.0.0.0/0`). **This is insecure for production but okay for learning.** Click "Confirm". (In production, you'd add only your server's specific IP).</li>
                            </ul>
                        </li>
                        <li>**Get Connection String:** Go back to your Cluster "Overview", click "Connect". Select "Connect your application". Choose "Node.js" as the driver and the latest version. **Copy the connection string**. It will look like:
                        <br><code>mongodb+srv://&lt;username&gt;:&lt;password&gt;@yourclustername.mongodb.net/?retryWrites=true&w=majority</code>
                        <br>You will need to replace `<username>` and `<password>` with the database user credentials you created. You should also add your desired database name before the `?` (MongoDB creates it if it doesn't exist):
                        <br><code>mongodb+srv://msmaxpro_user:YOUR_PASSWORD@yourclustername.mongodb.net/myAppData?retryWrites=true&w=majority</code>
                        <br>**Keep this complete string safe and private!**</li>
                    </ol>

                    <h3>Step 2: Install Mongoose Package</h3>
                    <p>Use npm to add the Mongoose library to your Node.js project.</p>                    
                    <h4>How to Perform (Terminal):</h4>
                    <p>Navigate to your project directory (e.g., `my-server`) and run:</p>
<pre><code>npm install mongoose
</code></pre>
                    <p>This adds `mongoose` to your `node_modules` and `package.json` dependencies.</p>

                    <h3>Step 3: Connect Your Express App</h3>
                    <p>Now, modify your main server file (`server.js` or `app.js`) to establish the connection when the application starts.</p>                    
                    <h4>How to Perform (Modify `server.js`):</h4>
<pre><code class="language-javascript">const express = require('express');
const mongoose = require('mongoose'); // Import mongoose

const app = express();
const PORT = process.env.PORT || 3000; // Use environment variable or default to 3000

// --- Database Connection ---
// IMPORTANT: Replace with your actual connection string!
// It's best practice to store this in an environment variable, not directly in code.
const MONGO_URI = 'mongodb+srv://msmaxpro_user:YOUR_PASSWORD@yourclustername.mongodb.net/myAppData?retryWrites=true&w=majority'; 

async function connectDB() {
  try {
    await mongoose.connect(MONGO_URI);
    console.log('MongoDB Connected Successfully! ✅');
    
    // Start listening for requests ONLY after the DB connection is successful
    app.listen(PORT, () => {
      console.log(`Server listening on port ${PORT}`);
    });

  } catch (error) {
    console.error('MongoDB Connection Error: ❌', error);
    process.exit(1); // Exit the process with failure code
  }
}

connectDB(); // Call the function to connect to the database

// --- Basic Route (Example) ---
app.get('/', (req, res) => {
  // Check connection status (optional)
  const dbStatus = mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected';
  res.send(`Hello World! DB Status: ${dbStatus}`); 
});

// --- Other routes and middleware will go here later ---

</code></pre>

                    <h4>Theory: Understanding the Connection Code</h4>
                    <ul>
                        <li>**`require('mongoose')`:** Loads the installed Mongoose library.</li>
                        <li>**`MONGO_URI`:** Holds your unique connection string from Atlas. **Security Note:** In real apps, you'd load this from environment variables (e.g., using a `.env` file and the `dotenv` package) instead of hardcoding it.</li>
                        <li>**`async function connectDB()`:** We wrap the connection logic in an `async` function to use `await`.</li>
                        <li>**`await mongoose.connect(MONGO_URI)`:** This is the core Mongoose function. It takes your connection string and attempts to connect to the MongoDB Atlas cluster. Because connecting to a remote database takes time (it's an asynchronous operation), `mongoose.connect()` returns a Promise. We use `await` to pause the `connectDB` function until the Promise resolves (connection successful) or rejects (connection failed).</li>
                        <li>**`try...catch` block:** This is essential for handling potential errors during the connection attempt (e.g., wrong password, network issues, IP not whitelisted).
                            <ul>
                                <li>**`try` block:** If `await mongoose.connect()` is successful, the code inside `try` continues. We log the success message and *then* start our Express server using `app.listen()`.</li>
                                <li>**`catch (error)` block:** If `await mongoose.connect()` fails (throws an error), the code inside `catch` executes. We log the specific error and use `process.exit(1)` to stop the Node.js application, as it likely cannot function correctly without a database connection.</li>
                            </ul>
                        </li>
                        <li>**`connectDB();`:** We call our async function to initiate the database connection process when the script starts.</li>
                         <li>**`mongoose.connection.readyState`:** (In the example route) This is an optional way to check the current connection status (1 means connected).</li>
                    </ul>
                    
                    <h4>How to Perform (Testing the Connection):</h4>
                    <ol>
                        <li>Replace the placeholder `MONGO_URI` with your actual connection string from Atlas.</li>
                        <li>Save `server.js`.</li>
                        <li>Run `node server.js` in your terminal.</li>
                        <li>Look for the `MongoDB Connected Successfully! ✅` message in your terminal. If you see an error, carefully check your connection string, username/password, and IP whitelist settings in Atlas.</li>
                        <li>Open `http://localhost:3000` in your browser. You should see the message including "DB Status: Connected".</li>
                    </ol>

                    <h2>Task: Defining Data Structure with Schemas & Models</h2>
                    <p>Now that we are connected, we need to define the structure of the data we want to store. Let's create a blueprint (Schema) and a tool (Model) for storing user information.</p>
                    
                    <h3>Schema: The Blueprint 📜</h3>
                    <p>A Schema maps to a MongoDB collection and defines the shape of the documents within that collection. It specifies fields, data types, and validation rules.</p>

                    <h4>How to Perform (Defining a User Schema):</h4>
                    <p>Add this code *after* the `connectDB()` call but *before* your routes in `server.js`. (In larger projects, Schemas and Models live in their own dedicated files, e.g., in a `models` folder).</p>
<pre><code class="language-javascript">// --- Define Schema & Model ---
const { Schema } = mongoose; // Destructure Schema from mongoose for convenience

const userSchema = new Schema({
  username: {
    type: String,
    required: [true, 'Username is required'], // Custom error message
    unique: true,
    trim: true, // Removes leading/trailing whitespace
    minlength: [3, 'Username must be at least 3 characters']
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    trim: true,
    lowercase: true, // Converts email to lowercase before saving
    match: [/.+\@.+\..+/, 'Please enter a valid email address'] // Basic email format validation
  },
  age: {
    type: Number,
    min: [13, 'Must be at least 13 years old'],
    max: 120
  },
  isVerified: {
    type: Boolean,
    default: false // Default value if not provided
  },
  createdAt: {
    type: Date,
    default: Date.now, // Automatically set timestamp on creation
    immutable: true // Cannot be changed after creation
  },
  updatedAt: {
    type: Date,
    default: Date.now // Automatically set timestamp, updates on save
  }
});

// Mongoose Middleware (Example: update 'updatedAt' on save)
userSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});
</code></pre>
                    <h4>Theory: Understanding the Schema Definition</h4>
                    <ul>
                        <li>`new mongoose.Schema({...})`: Creates a new schema instance.</li>
                        <li>**Field Definitions:** Each key in the object (`username`, `email`, etc.) defines a field in the document.</li>
                        <li>**Type:** Specifies the expected data type (`String`, `Number`, `Boolean`, `Date`, `Array`, `ObjectId` for relationships, etc.).</li>
                        <li>**Validation:** Mongoose provides built-in validators:
                            <ul>
                                <li>`required: true` or `[true, 'Error message']`: The field cannot be empty.</li>
                                <li>`unique: true`: Ensures no two documents in the collection have the same value for this field (creates a MongoDB index).</li>
                                <li>`trim: true`: Removes whitespace from the beginning and end of strings.</li>
                                <li>`lowercase: true` / `uppercase: true`: Converts strings.</li>
                                <li>`minlength`, `maxlength`: For strings.</li>
                                <li>`min`, `max`: For numbers.</li>
                                <li>`match: /regex/`: Validates strings against a regular expression.</li>
                                <li>`enum: ['value1', 'value2']`: Restricts strings to a specific set of values.</li>
                            </ul>
                        </li>
                        <li>**Default Values:** `default: ...` provides a value if one isn't specified during creation (`Date.now` is common for timestamps).</li>
                        <li>**`immutable: true`:** Prevents a field from being modified after the document is created.</li>
                        <li>**Middleware (`.pre('save', ...)`):** A function that runs *before* a specified operation (like `save`). Here, we ensure the `updatedAt` field is always updated whenever a document is saved. `this` refers to the document being saved. `next()` must be called to proceed with the save operation.</li>
                    </ul>

                    <h3>Model: The Working Tool 🛠️</h3>
                    <p>The Model is what you actually use in your code to interact with the database collection. It's created from the Schema.</p>                    
                    <h4>How to Perform (Creating the User Model):</h4>
                    <p>Add this line immediately after the `userSchema` definition:</p>
<pre><code class="language-javascript">// Create the 'User' model using the 'userSchema'
// Mongoose will create/use a collection named 'users' (pluralized, lowercased)
const User = mongoose.model('User', userSchema); 
</code></pre>
                    <p>Now, the constant `User` is our powerful tool to perform CRUD operations on the `users` collection in MongoDB, following the rules defined in `userSchema`.</p>

                    <h2>Task: Performing CRUD Operations with Mongoose</h2>
                    <p>Let's create Express routes to handle the basic Create, Read, Update, and Delete operations for our users.</p>
                    
                    <h3>Middleware Setup: `express.json()`</h3>
                    <p>To handle incoming JSON data in POST and PATCH/PUT requests (like when submitting a form via JavaScript), we need to tell Express to parse it.</p>
                    <h4>How to Perform (Add near the top of `server.js`, after `const app = express();`):</h4>
<pre><code class="language-javascript">// --- Middleware ---
// This line tells Express to automatically parse incoming JSON request bodies
// The parsed data will be available on `req.body`
app.use(express.json()); 
</code></pre>

                    <h3>1. Create (POST /users)</h3>
                    <p>This route will handle creating a new user document.</p>                    
                    <h4>How to Perform (Add this route definition):</h4>
<pre><code class="language-javascript">// --- CRUD Routes for Users ---

// CREATE a new user
app.post('/users', async (req, res) => {
  console.log('Request Body:', req.body); // Log incoming data
  try {
    // 1. Create a new document instance using the User model and request body data
    const newUser = new User({
      username: req.body.username,
      email: req.body.email,
      age: req.body.age 
      // 'createdAt' and 'updatedAt' will be set by defaults/middleware
      // 'isVerified' will default to false
    });
    
    // 2. Attempt to save the document to the database
    // Mongoose will run validation rules defined in the schema here
    const savedUser = await newUser.save(); 
    
    // 3. Respond with status 201 (Created) and the saved document
    console.log('User saved:', savedUser);
    res.status(201).json(savedUser); 
  } catch (error) {
    // 4. If validation fails or another error occurs (e.g., unique constraint)
    console.error('Error saving user:', error.message);
    res.status(400).json({ message: "Error creating user", details: error.message }); 
  }
});
</code></pre>
                    <h4>Theory & How to Test:</h4>
                    <ul>
                        <li>**`app.post('/users', ...)`:** Defines a handler for POST requests to the `/users` path.</li>
                        <li>**`async (req, res)`:** We use `async` because `newUser.save()` is asynchronous.</li>
                        <li>**`req.body`:** Thanks to `app.use(express.json())`, Express parses the incoming JSON data and makes it available here.</li>
                        <li>**`new User(...)`:** Creates a new Mongoose document in memory based on the schema.</li>
                        <li>**`await newUser.save()`:** Attempts to save the document to the MongoDB `users` collection. This returns the saved document (including the auto-generated `_id` and default values).</li>
                        <li>**`res.status(201).json(...)`:** Sends an HTTP status code 201 (meaning "Created") and sends the newly created user document back as JSON.</li>
                        <li>**`catch (error)`:** Catches errors (like validation errors or if the username/email is already taken) and sends back a 400 (Bad Request) status with an error message.</li>
                        <li>**Testing:** You can't easily test POST requests directly in a browser. Use tools like **Postman** or **Insomnia** (or `curl` in the terminal) to send a POST request to `http://localhost:3000/users` with a JSON body like: `{ "username": "testuser", "email": "test@example.com", "age": 25 }`.</li>
                    </ul>

                    <h3>2. Read (GET /users, GET /users/:id)</h3>
                    <p>These routes will handle fetching user documents.</p>                    
                    <h4>How to Perform (Add these route definitions):</h4>
<pre><code class="language-javascript">// READ all users
app.get('/users', async (req, res) => {
  try {
    // 1. Find all documents in the 'users' collection
    // You can add query filters inside find(), e.g. User.find({ age: { $gt: 18 } })
    const users = await User.find(); 
    
    // 2. Respond with the array of users
    res.json(users);
  } catch (error) {
    // 3. Handle potential server errors
    console.error('Error fetching users:', error.message);
    res.status(500).json({ message: "Error fetching users", details: error.message });
  }
});

// READ one user by their unique ID
app.get('/users/:id', async (req, res) => {
  try {
    const userId = req.params.id; // Get the ID from the URL parameter
    console.log('Fetching user with ID:', userId);

    // 1. Find a single document by its _id
    const user = await User.findById(userId); 
    
    // 2. If no user is found with that ID
    if (!user) {
      console.log('User not found');
      return res.status(404).json({ message: 'User not found' }); // Use return to stop execution
    }
    
    // 3. Respond with the found user document
    console.log('User found:', user);
    res.json(user);
  } catch (error) {
    // 4. Handle potential server errors (e.g., invalid ID format)
    console.error('Error fetching user by ID:', error.message);
    res.status(500).json({ message: "Error fetching user", details: error.message });
  }
});
</code></pre>
                     <h4>Theory & How to Test:</h4>
                    <ul>
                        <li>**`app.get(...)`:** Defines handlers for GET requests.</li>
                        <li>**`await User.find()`:** Fetches all documents from the `users` collection. Returns an array (which might be empty).</li>
                        <li>**`/users/:id`:** This defines a route parameter. `:id` means Express will capture whatever value is in the URL at that position (e.g., in `/users/123xyz`, `req.params.id` will be `"123xyz"`).</li>
                        <li>**`await User.findById(userId)`:** Fetches a single document whose `_id` matches the provided `userId`. Returns the document or `null` if not found.</li>
                        <li>**`res.json(...)`:** Sends the found user(s) back as JSON.</li>
                         <li>**`res.status(404)`:** Sends a "Not Found" status if `findById` returns `null`.</li>
                         <li>**`res.status(500)`:** Sends an "Internal Server Error" status for unexpected errors.</li>
                        <li>**Testing:** Open `http://localhost:3000/users` in your browser to see all users. After creating a user, copy its `_id` and go to `http://localhost:3000/users/PASTE_ID_HERE` to see that specific user.</li>
                    </ul>
                    
                    <h3>3. Update (PATCH /users/:id)</h3>
                    <p>This route modifies an existing user document.</p>                    
                    <h4>How to Perform (Add this route definition):</h4>
<pre><code class="language-javascript">// UPDATE a user by ID
// PATCH is often preferred over PUT for partial updates
app.patch('/users/:id', async (req, res) => {
  try {
    const userId = req.params.id;
    const updates = req.body; // The fields to update from the request body
    console.log('Updating user:', userId, 'with data:', updates);

    // 1. Find the document by ID and update it with the new data
    const updatedUser = await User.findByIdAndUpdate(
      userId, 
      updates, 
      { 
        new: true, // Option: return the modified document, not the original
        runValidators: true // Option: run schema validation rules on the update data
      } 
    );
    
    // 2. If no user was found to update
     if (!updatedUser) {
       console.log('User not found for update');
       return res.status(404).json({ message: 'User not found' });
    }
    
    // 3. Respond with the updated user document
    console.log('User updated:', updatedUser);
    res.json(updatedUser);
  } catch (error) {
    // 4. Handle validation errors or other issues
    console.error('Error updating user:', error.message);
    res.status(400).json({ message: "Error updating user", details: error.message }); 
  }
});
</code></pre>
                    <h4>Theory & How to Test:</h4>
                    <ul>
                        <li>**`app.patch(...)`:** Defines a handler for PATCH requests (used for partial updates). PUT is also used, often for replacing the entire resource.</li>
                         <li>**`await User.findByIdAndUpdate(id, updates, options)`:** Finds a document by `id` and applies the `updates` from `req.body`.
                            <ul>
                                <li>**`{ new: true }`:** Ensures that the `updatedUser` variable contains the document *after* the update has been applied (otherwise it returns the old version by default).</li>
                                <li>**`{ runValidators: true }`:** Tells Mongoose to re-run the schema validation rules (like `required`, `minlength`) on the `updates` data before saving.</li>
                            </ul>
                        </li>
                         <li>**Testing:** Use Postman/Insomnia. First, get the `_id` of a user you created. Then, send a PATCH request to `http://localhost:3000/users/PASTE_ID_HERE` with a JSON body containing the fields you want to change, e.g., `{ "age": 26 }`. Check the response and also try fetching the user again via GET to confirm the update.</li>
                    </ul>

                    <h3>4. Delete (DELETE /users/:id)</h3>
                    <p>This route removes a user document.</p>                    
                    <h4>How to Perform (Add this route definition):</h4>
<pre><code class="language-javascript">// DELETE a user by ID
app.delete('/users/:id', async (req, res) => {
  try {
    const userId = req.params.id;
    console.log('Deleting user with ID:', userId);

    // 1. Find the document by ID and remove it
    const deletedUser = await User.findByIdAndDelete(userId);
    
    // 2. If no user was found to delete
     if (!deletedUser) {
       console.log('User not found for deletion');
       return res.status(404).json({ message: 'User not found' });
    }
    
    // 3. Respond with a success message
    console.log('User deleted:', deletedUser);
    res.json({ message: 'User deleted successfully', deletedUser: deletedUser });
  } catch (error) {
    // 4. Handle potential server errors
    console.error('Error deleting user:', error.message);
    res.status(500).json({ message: "Error deleting user", details: error.message });
  }
});
</code></pre>
                    <h4>Theory & How to Test:</h4>
                    <ul>
                        <li>**`app.delete(...)`:** Defines a handler for DELETE requests.</li>
                         <li>**`await User.findByIdAndDelete(id)`:** Finds a document by `id` and removes it from the database. It returns the deleted document (or `null` if not found).</li>
                         <li>**Testing:** Use Postman/Insomnia. Get the `_id` of a user. Send a DELETE request to `http://localhost:3000/users/PASTE_ID_HERE`. You should get a success message. Try fetching that user again via GET – you should now get a 404 Not Found error.</li>
                    </ul>

                    <h2>Conclusion: Persistent Data Power! 💪</h2>
                    <p>You've now equipped your backend with the ability to remember! By connecting Node.js/Express to MongoDB using Mongoose, defining data structures with Schemas and Models, and implementing CRUD operations, you can build applications that store and manage user data, content, and much more.</p>
                    <p>This is a fundamental skill for any backend developer. The next logical steps are to learn how to create relationships between different data models (e.g., linking posts to users), implement user authentication, and design more complex APIs (Application Programming Interfaces) for your frontend to interact with.</p>

                </article>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CodeWithMSMAXPRO. All rights reserved.</p>
        </div>
    </footer>
    
    <script>
        /* --- Mobile Navigation Toggle --- */
        const navSlide = () => {
            const hamburger = document.querySelector('.hamburger');
            const nav = document.querySelector('.nav-links');

            // Check if hamburger and nav exist on the page
            if (hamburger && nav) {
                hamburger.addEventListener('click', () => {
                    // Toggle Nav
                    nav.classList.toggle('nav-active');
                    
                    // Hamburger Animation
                    hamburger.classList.toggle('toggle');
                });
            }
        }

        // Call the function to set up the event listener
        navSlide();
    </script>

</body>
</html>
